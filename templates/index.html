<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Agent Interface</title>
    <!-- Add Marked.js for Markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Add highlight.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script>
        // Initialize highlight.js when loaded
        document.addEventListener('DOMContentLoaded', (event) => {
            if (typeof hljs !== 'undefined') {
                hljs.configure({ ignoreUnescapedHTML: true });
            }
            
            // Set up auto-fix toggle functionality
            document.getElementById('auto-fix-toggle').checked = autoFixEnabled;
            
            // Add event listener for auto-fix toggle
            document.getElementById('auto-fix-toggle').addEventListener('change', (e) => {
                autoFixEnabled = e.target.checked;
                localStorage.setItem('autoFixEnabled', autoFixEnabled);
                console.log(`Auto-fix errors: ${autoFixEnabled ? 'enabled' : 'disabled'}`);
            });
            
            // Set up auto-run toggle functionality
            document.getElementById('auto-run-toggle').checked = autoRunEnabled;
            
            // Add event listener for auto-run toggle
            document.getElementById('auto-run-toggle').addEventListener('change', (e) => {
                autoRunEnabled = e.target.checked;
                localStorage.setItem('autoRunEnabled', autoRunEnabled);
                console.log(`Auto-run code: ${autoRunEnabled ? 'enabled' : 'disabled'}`);
            });
        });
    </script>
    <style>
        :root {
            /* Light mode colors */
            --background-color: #f5f5f5;
            --text-color: #333;
            --secondary-text-color: #666;
            --container-bg: #ffffff;
            --container-shadow: rgba(0, 0, 0, 0.1);
            --user-message-bg: #e1f5fe;
            --assistant-message-bg: #f1f1f1;
            --input-border: #ddd;
            --primary-btn-bg: #2196F3;
            --primary-btn-hover: #0b7dda;
            --danger-btn-bg: #f44336;
            --danger-btn-hover: #d32f2f;
            --code-bg: #f8f8f8;
            --code-text-color: #333333;
            --blockquote-border: #ccc;
            --blockquote-color: #666;
            --table-border: #ddd;
            --table-header-bg: #f2f2f2;
            --panel-border: #ddd;
            --panel-header-bg: #f2f2f2;
            --inactive-tab-bg: #e0e0e0;
            --active-tab-bg: #ffffff;
        }
        
        /* Dark mode colors */
        [data-theme="dark"] {
            --background-color: #121212;
            --text-color: #e0e0e0;
            --secondary-text-color: #aaaaaa;
            --container-bg: #1e1e1e;
            --container-shadow: rgba(0, 0, 0, 0.3);
            --user-message-bg: #1a3a4a;
            --assistant-message-bg: #2a2a2a;
            --input-border: #444;
            --primary-btn-bg: #1976D2;
            --primary-btn-hover: #1565C0;
            --danger-btn-bg: #d32f2f;
            --danger-btn-hover: #b71c1c;
            --code-bg: #2d2d2d;
            --code-text-color: #4CAF50;
            --blockquote-border: #555;
            --blockquote-color: #aaa;
            --table-border: #444;
            --table-header-bg: #2d2d2d;
        }
        
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--background-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        h1 {
            color: var(--text-color);
            text-align: center;
        }
        
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .controls-container {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .model-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .model-dropdown {
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid var(--input-border);
            background-color: var(--container-bg);
            color: var(--text-color);
            font-size: 14px;
            cursor: pointer;
        }
        
        .model-dropdown:focus {
            outline: none;
            border-color: var(--primary-btn-bg);
        }
        
        .theme-toggle {
            display: flex;
            align-items: center;
        }
        
        .theme-toggle label {
            margin-right: 10px;
            cursor: pointer;
        }
        
        .theme-toggle-checkbox {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
        }
        
        .theme-toggle-checkbox input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #2196F3;
        }
        
        input:checked + .slider:before {
            transform: translateX(30px);
        }
        
        .model-info {
            text-align: center;
            margin-bottom: 20px;
            color: var(--secondary-text-color);
        }
        
        /* Split panel layout */
        .main-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .panel {
            flex: 1;
            background-color: var(--container-bg);
            border-radius: 8px;
            box-shadow: 0 2px 10px var(--container-shadow);
            height: 500px;
            display: flex;
            flex-direction: column;
        }
        
        .panel-header {
            padding: 10px 15px;
            background-color: var(--panel-header-bg);
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            border-bottom: 1px solid var(--panel-border);
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .chat-container {
            height: 100%;
            overflow-y: auto;
        }
        
        /* Code panel */
        .code-panel-tabs {
            display: flex;
            background-color: var(--panel-header-bg);
            border-bottom: 1px solid var(--panel-border);
        }
        
        .code-tab {
            padding: 8px 15px;
            cursor: pointer;
            background-color: var(--inactive-tab-bg);
            border-right: 1px solid var(--panel-border);
        }
        
        .code-tab.active {
            background-color: var(--active-tab-bg);
            border-bottom: 2px solid var(--primary-btn-bg);
        }
        
        .code-editor {
            height: 300px;
            border: 1px solid var(--input-border);
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            background-color: var(--code-bg);
            color: var(--code-text-color);
            resize: none;
            width: 100%;
            box-sizing: border-box;
        }
        
        .code-output {
            margin-top: 10px;
            border: 1px solid var(--input-border);
            border-radius: 4px;
            padding: 10px;
            background-color: var(--code-bg);
            height: 100px;
            overflow-y: auto;
            font-family: monospace;
            white-space: pre-wrap;
        }
        
        .message-wrapper {
            clear: both;
            overflow: hidden;
            margin-bottom: 15px;
            width: 100%;
        }
        
        .message {
            padding: 10px 15px;
            border-radius: 18px;
            max-width: 80%;
            word-wrap: break-word;
            position: relative;
        }
        
        .model-tag {
            font-size: 10px;
            color: var(--secondary-text-color);
            position: absolute;
            bottom: -15px;
            left: 5px;
            background-color: var(--container-bg);
            padding: 2px 5px;
            border-radius: 3px;
            border: 1px solid var(--input-border);
            z-index: 1;
        }
        
        .current-model-indicator {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            font-size: 12px;
            color: var(--secondary-text-color);
            margin-top: 5px;
        }
        
        .auto-toggles {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .auto-fix-toggle, .auto-run-toggle {
            display: flex;
            align-items: center;
            gap: 5px;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--input-border);
            margin-bottom: 15px;
        }
        
        .model-name {
            font-weight: bold;
            color: var(--text-color);
        }
        
        /* Code execution styles */
        .code-block-container {
            position: relative;
            margin: 10px 0;
        }
        
        .code-actions {
            position: absolute;
            top: 5px;
            right: 5px;
            display: flex;
            gap: 5px;
        }
        
        .execute-button, .clear-button {
            background-color: var(--primary-btn-bg);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 2px 8px;
            font-size: 12px;
            cursor: pointer;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        
        .execute-button:hover, .clear-button:hover {
            opacity: 1;
        }
        
        .clear-button {
            background-color: var(--danger-btn-bg);
        }
        
        .code-result {
            background-color: var(--code-bg);
            border: 1px solid var(--input-border);
            border-radius: 4px;
            padding: 10px;
            margin-top: 5px;
            white-space: pre-wrap;
            font-family: monospace;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .code-error {
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px solid rgba(255, 0, 0, 0.3);
            color: #d32f2f;
        }
        
        .fix-code-button {
            margin-top: 10px;
            padding: 5px 10px;
            background-color: var(--primary-btn-bg);
            color: var(--primary-btn-text);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .fix-code-button:hover {
            background-color: var(--primary-btn-hover-bg);
        }
        
        .auto-fixing-message {
            margin-top: 10px;
            font-style: italic;
            color: var(--secondary-text-color);
        }
        
        @keyframes highlight {
            0% { border-color: var(--primary-btn-bg); }
            50% { border-color: var(--primary-btn-bg); }
            100% { border-color: var(--panel-border); }
        }
        
        .highlight-animation {
            animation: highlight 2s ease;
            border: 2px solid var(--panel-border);
            transition: border-color 2s ease;
        }
        
        .code-moved-message {
            background-color: var(--panel-header-bg);
            border: 1px solid var(--panel-border);
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            font-size: 14px;
            color: var(--secondary-text-color);
            text-align: center;
        }
        
        .user-message {
            background-color: var(--user-message-bg);
            float: right;
            margin-left: auto;
            border-bottom-right-radius: 5px;
            text-align: right;
        }
        
        .assistant-message {
            background-color: var(--assistant-message-bg);
            float: left;
            margin-right: auto;
            border-bottom-left-radius: 5px;
            text-align: left;
        }
        
        .input-container {
            display: flex;
            gap: 10px;
        }
        
        #message-input {
            flex: 1;
            padding: 10px;
            border: 1px solid var(--input-border);
            border-radius: 4px;
            font-size: 16px;
            background-color: var(--container-bg);
            color: var(--text-color);
        }
        
        button {
            padding: 10px 20px;
            background-color: var(--primary-btn-bg);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s ease;
        }
        
        button:hover {
            background-color: var(--primary-btn-hover);
        }
        
        #clear-btn {
            background-color: var(--danger-btn-bg);
        }
        
        #clear-btn:hover {
            background-color: var(--danger-btn-hover);
        }
        
        .buttons {
            display: flex;
            gap: 10px;
        }
        
        pre {
            white-space: pre-wrap;
            background-color: var(--code-bg);
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        
        code {
            font-family: 'Courier New', Courier, monospace;
        }
        
        /* Additional styles for markdown content */
        .assistant-message h1, .assistant-message h2, .assistant-message h3 {
            margin-top: 10px;
            margin-bottom: 10px;
            color: var(--text-color);
        }
        
        .assistant-message ul, .assistant-message ol {
            padding-left: 20px;
        }
        
        .assistant-message blockquote {
            border-left: 3px solid var(--blockquote-border);
            padding-left: 10px;
            margin-left: 0;
            color: var(--blockquote-color);
        }
        
        .assistant-message table {
            border-collapse: collapse;
            width: 100%;
        }
        
        .assistant-message th, .assistant-message td {
            border: 1px solid var(--table-border);
            padding: 8px;
        }
        
        .assistant-message th {
            background-color: var(--table-header-bg);
        }
    </style>
</head>
<body>
    <div class="header-container">
        <h1>Simple Agent Interface</h1>
        <div class="controls-container">
            <div class="model-selector">
                <label for="model-select">Model:</label>
                <select id="model-select" class="model-dropdown">
                    {% for model in available_models %}
                    <option value="{{ model }}" {% if model == model_name %}selected{% endif %}>{{ model }}</option>
                    {% endfor %}
                </select>
            </div>
            <div class="theme-toggle">
                <label for="theme-toggle">Dark Mode</label>
                <label class="theme-toggle-checkbox">
                    <input type="checkbox" id="theme-toggle">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
    </div>
    
    <div class="current-model-indicator">
        <div>Currently using model: <span class="model-name" id="current-model-display">{{ model_name }}</span></div>
        <div class="auto-toggles">
            <div class="auto-fix-toggle">
                <label for="auto-fix-toggle">Auto-Fix Errors</label>
                <label class="theme-toggle-checkbox">
                    <input type="checkbox" id="auto-fix-toggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="auto-run-toggle">
                <label for="auto-run-toggle">Auto-Run Code</label>
                <label class="theme-toggle-checkbox">
                    <input type="checkbox" id="auto-run-toggle">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
    </div>
    
    <div class="main-container">
        <!-- Chat Panel -->
        <div class="panel chat-panel">
            <div class="panel-header">
                Chat
            </div>
            <div class="panel-content">
                <div id="chat-container" class="chat-container"></div>
            </div>
        </div>
        
        <!-- Code Panel -->
        <div class="panel code-panel">
            <div class="panel-header">
                Code Playground
                <div>
                    <select id="code-language-select" class="model-dropdown">
                        <option value="python">Python</option>
                        <option value="javascript">JavaScript</option>
                        <option value="bash">Bash</option>
                    </select>
                    <button id="run-code-btn" class="execute-button">Run</button>
                    <button id="clear-code-btn" class="clear-button">Clear</button>
                </div>
            </div>
            <div class="panel-content">
                <textarea id="code-editor" class="code-editor" placeholder="Write your code here..."></textarea>
                <div id="code-output" class="code-output">Output will appear here...</div>
            </div>
        </div>
    </div>
    
    <div class="input-container">
        <input type="text" id="message-input" placeholder="Type your message here..." autocomplete="off">
        <div class="buttons">
            <button id="send-btn">Send</button>
            <button id="clear-btn">Clear Chat</button>
        </div>
    </div>

    <script>
        // Check for saved theme preference or use system preference
        function getThemePreference() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                return savedTheme;
            }
            return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }
        
        // Apply theme
        function applyTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            document.getElementById('theme-toggle').checked = theme === 'dark';
        }
        
        // Initialize theme
        document.addEventListener('DOMContentLoaded', () => {
            applyTheme(getThemePreference());
            
            // Add theme toggle event listener
            document.getElementById('theme-toggle').addEventListener('change', (e) => {
                applyTheme(e.target.checked ? 'dark' : 'light');
            });
        });
        
        // Store current model, chat history, and settings
        let currentModel = document.getElementById('model-select').value;
        let chatHistory = [];
        let autoFixEnabled = localStorage.getItem('autoFixEnabled') === 'true' || false;
        let autoRunEnabled = localStorage.getItem('autoRunEnabled') === 'true' || false;
        
        // DOM elements
        const chatContainer = document.getElementById('chat-container');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-btn');
        const clearButton = document.getElementById('clear-btn');
        
        // Function to add a message to the chat
        function addMessageToChat(role, content, id = null, model = null) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message');
            if (id) messageDiv.id = id;
            
            if (role === 'user') {
                messageDiv.classList.add('user-message');
                messageDiv.textContent = content;
            } else {
                messageDiv.classList.add('assistant-message');
                
                // Parse markdown content using marked.js
                messageDiv.innerHTML = content ? marked.parse(content) : '';
                
                // Apply syntax highlighting to code blocks if hljs is available
                if (window.hljs && content) {
                    messageDiv.querySelectorAll('pre code').forEach((block) => {
                        hljs.highlightElement(block);
                    });
                }
                
                // Process code blocks if this is an assistant message
                if (role === 'assistant' && content) {
                    // First extract code from the response and place it in the code playground
                    // This will replace code blocks with messages
                    extractAndPlaceCode(messageDiv);
                    
                    // Then add execute buttons to any remaining code blocks
                    // (in case there are non-supported language code blocks)
                    addCodeExecutionButtons(messageDiv);
                }
                
                // Add model tag if provided
                if (model) {
                    const modelTag = document.createElement('div');
                    modelTag.classList.add('model-tag');
                    modelTag.textContent = `Model: ${model}`;
                    messageDiv.appendChild(modelTag);
                }
            }
            
            // Add a wrapper div to ensure proper ordering
            const messageWrapper = document.createElement('div');
            messageWrapper.classList.add('message-wrapper');
            messageWrapper.appendChild(messageDiv);
            
            chatContainer.appendChild(messageWrapper);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
        
        // Function to send a message to the agent
        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message) return;
            
            // Clear input
            messageInput.value = '';
            
            // Generate a unique response ID for this message
            const responseId = 'response-' + Date.now();
            
            // Add user message to chat
            addMessageToChat('user', message);
            
            // Create a placeholder for the assistant's response
            addMessageToChat('assistant', '', responseId, currentModel);
            
            try {
                // Send message to the agent with streaming
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: message,
                        history: chatHistory,
                        stream: true,
                        model: currentModel
                    })
                });
                
                // Create a reader for the response body stream
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                
                // Process the stream
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    // Decode the chunk and add it to the buffer
                    buffer += decoder.decode(value, { stream: true });
                    
                    // Process complete events in the buffer
                    let eventStart = buffer.indexOf('data: ');
                    let eventEnd = buffer.indexOf('\n\n', eventStart);
                    
                    while (eventStart >= 0 && eventEnd >= 0) {
                        // Extract and parse the event data
                        const eventData = buffer.substring(eventStart + 6, eventEnd);
                        try {
                            const data = JSON.parse(eventData);
                            
                            if (data.done) {
                                // Stream is complete, update chat history
                                chatHistory = data.history;
                                
                                // Update current model if it was changed for this request
                                if (data.model) {
                                    currentModel = data.model;
                                    
                                    // Update the model tag in the response
                                    const currentResponse = document.getElementById(responseId);
                                    if (currentResponse) {
                                        let modelTag = currentResponse.querySelector('.model-tag');
                                        if (!modelTag) {
                                            modelTag = document.createElement('div');
                                            modelTag.classList.add('model-tag');
                                            currentResponse.appendChild(modelTag);
                                        }
                                        modelTag.textContent = `Model: ${data.model}`;
                                    }
                                    
                                    // Update the model selector to match
                                    const modelSelect = document.getElementById('model-select');
                                    if (modelSelect && modelSelect.value !== data.model) {
                                        modelSelect.value = data.model;
                                        
                                        // Also update the current model display in the header
                                        document.getElementById('current-model-display').textContent = data.model;
                                    }
                                }
                            } else {
                                // Update the placeholder with the current full response
                                const currentResponse = document.getElementById(responseId);
                                if (currentResponse) {
                                    // Save the model tag if it exists
                                    const existingModelTag = currentResponse.querySelector('.model-tag');
                                    let modelName = currentModel;
                                    if (existingModelTag) {
                                        // Extract model name from the tag text if it exists
                                        const tagText = existingModelTag.textContent;
                                        const match = tagText.match(/Model: (.+)/);
                                        if (match && match[1]) {
                                            modelName = match[1];
                                        }
                                    }
                                    
                                    // Parse markdown content using marked.js
                                    currentResponse.innerHTML = marked.parse(data.full);
                                    
                                    // Apply syntax highlighting to code blocks if hljs is available
                                    if (window.hljs) {
                                        currentResponse.querySelectorAll('pre code').forEach((block) => {
                                            hljs.highlightElement(block);
                                        });
                                    }
                                    
                                    // First extract code from the response and place it in the code playground
                                    // This will replace code blocks with messages
                                    extractAndPlaceCode(currentResponse);
                                    
                                    // Then add execute buttons to any remaining code blocks
                                    // (in case there are non-supported language code blocks)
                                    addCodeExecutionButtons(currentResponse);
                                    
                                    // Always add a model tag with the correct model
                                    const modelTag = document.createElement('div');
                                    modelTag.classList.add('model-tag');
                                    modelTag.textContent = `Model: ${modelName}`;
                                    currentResponse.appendChild(modelTag);
                                    
                                    // Scroll to bottom as content is added
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                }
                            }
                        } catch (e) {
                            console.error('Error parsing event data:', e);
                        }
                        
                        // Remove the processed event from the buffer
                        buffer = buffer.substring(eventEnd + 2);
                        
                        // Look for the next event
                        eventStart = buffer.indexOf('data: ');
                        eventEnd = buffer.indexOf('\n\n', eventStart);
                    }
                }
                
            } catch (error) {
                // Add error message to chat
                const currentResponse = document.getElementById(responseId);
                if (currentResponse) {
                    currentResponse.textContent = `Error: ${error.message}`;
                }
            }
        }
        
        // Function to clear the chat
        function clearChat() {
            chatContainer.innerHTML = '';
            chatHistory = [];
            
            // Add a welcome message
            addMessageToChat('assistant', 'Hello! How can I help you today?', null, currentModel);
        }
        
        // Event listeners
        sendButton.addEventListener('click', sendMessage);
        
        messageInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        });
        
        clearButton.addEventListener('click', clearChat);
        
        // Function to add code execution buttons to code blocks
        const addCodeExecutionButtons = function(container) {
            container.querySelectorAll('pre code').forEach((codeBlock) => {
                // Check if this code block already has execution buttons
                if (codeBlock.parentNode.parentNode.classList.contains('code-block-container')) {
                    return;
                }
                
                // Get the language from the class
                let language = 'python';  // Default to Python
                const classes = codeBlock.className.split(' ');
                for (const cls of classes) {
                    if (cls.startsWith('language-')) {
                        language = cls.replace('language-', '');
                        break;
                    }
                }
                
                // Only add execution buttons for supported languages
                if (['python', 'javascript', 'js', 'bash', 'shell', 'sh'].includes(language)) {
                    // Map some language aliases
                    if (language === 'js') language = 'javascript';
                    if (language === 'sh') language = 'bash';
                    
                    // Create a container for the code block
                    const container = document.createElement('div');
                    container.classList.add('code-block-container');
                    container.dataset.language = language;
                    
                    // Create the actions div
                    const actions = document.createElement('div');
                    actions.classList.add('code-actions');
                    
                    // Create the execute button
                    const executeButton = document.createElement('button');
                    executeButton.classList.add('execute-button');
                    executeButton.textContent = `Run ${language}`;
                    executeButton.addEventListener('click', function() {
                        executeCode(codeBlock.textContent, language, container);
                    });
                    
                    // Create the copy to playground button
                    const copyButton = document.createElement('button');
                    copyButton.classList.add('execute-button');
                    copyButton.textContent = 'Copy to Playground';
                    copyButton.addEventListener('click', function() {
                        copyToPlayground(codeBlock.textContent, language);
                    });
                    
                    // Add the buttons to the actions
                    actions.appendChild(executeButton);
                    actions.appendChild(copyButton);
                    
                    // Replace the pre element with our container
                    const preElement = codeBlock.parentNode;
                    preElement.parentNode.replaceChild(container, preElement);
                    
                    // Add the pre element and actions to the container
                    container.appendChild(preElement);
                    container.appendChild(actions);
                }
            });
        }
        
        // Function to execute code
        async function executeCode(code, language, container) {
            // Create a result div if it doesn't exist
            let resultDiv = container.querySelector('.code-result');
            if (!resultDiv) {
                resultDiv = document.createElement('div');
                resultDiv.classList.add('code-result');
                container.appendChild(resultDiv);
            }
            
            // Show loading state
            resultDiv.textContent = 'Executing...';
            resultDiv.classList.remove('code-error');
            
            try {
                // Send the code to the server for execution
                const response = await fetch('/api/execute', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        code: code,
                        language: language
                    })
                });
                
                const data = await response.json();
                
                // Display the result
                if (data.error) {
                    resultDiv.textContent = `Error: ${data.error}`;
                    resultDiv.classList.add('code-error');
                } else {
                    resultDiv.textContent = data.result || 'Code executed successfully with no output.';
                    resultDiv.classList.remove('code-error');
                }
                
                // Also update the code playground with this code for further experimentation
                document.getElementById('code-editor').value = code;
                document.getElementById('code-language-select').value = language;
                
                // If this is the main code editor, also update the output panel
                if (container === document.body) {
                    const codeOutput = document.getElementById('code-output');
                    if (data.error) {
                        codeOutput.textContent = `Error: ${data.error}`;
                        codeOutput.classList.add('code-error');
                    } else {
                        codeOutput.textContent = data.result || 'Code executed successfully with no output.';
                        codeOutput.classList.remove('code-error');
                    }
                }
            } catch (error) {
                resultDiv.textContent = `Error: ${error.message}`;
                resultDiv.classList.add('code-error');
                
                // If this is the main code editor, also update the output panel
                if (container === document.body) {
                    const codeOutput = document.getElementById('code-output');
                    codeOutput.textContent = `Error: ${error.message}`;
                    codeOutput.classList.add('code-error');
                }
            }
            
            // Scroll to make the result visible
            resultDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        
        // Debounce function to prevent multiple rapid calls
        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), wait);
            };
        }
        
        // Helper function to normalize indentation (convert tabs to spaces, ensure consistent indentation)
        function normalizeIndentation(code) {
            // Convert tabs to spaces (4 spaces per tab)
            let normalized = code.replace(/\t/g, '    ');
            
            // Split into lines
            const lines = normalized.split('\n');
            
            // Find the minimum indentation level (ignoring empty lines)
            let minIndent = Infinity;
            for (const line of lines) {
                if (line.trim() === '') continue; // Skip empty lines
                const indent = line.match(/^\s*/)[0].length;
                if (indent < minIndent) minIndent = indent;
            }
            
            // If there's a common indentation, remove it from all lines
            if (minIndent > 0 && minIndent < Infinity) {
                normalized = lines.map(line => {
                    if (line.trim() === '') return line;
                    return line.substring(minIndent);
                }).join('\n');
            }
            
            return normalized;
        }
        
        // Function to extract code from a message and place it in the code playground
        const extractAndPlaceCodeImpl = function(messageElement) {
            // Find all code blocks in the message
            const codeBlocks = messageElement.querySelectorAll('pre code');
            if (codeBlocks.length === 0) return;
            
            // Check if this is a response to a fix request
            const isFixResponse = messageElement.closest('.message-wrapper').previousElementSibling?.querySelector('.user-message')?.textContent.includes('Please fix this');
            
            // Flag to track if we should auto-run the code
            let shouldAutoRun = autoRunEnabled;
            
            // Process all code blocks
            codeBlocks.forEach((codeBlock, index) => {
                // Get the language from the class
                let language = 'python';  // Default to Python
                const classes = codeBlock.className.split(' ');
                for (const cls of classes) {
                    if (cls.startsWith('language-')) {
                        language = cls.replace('language-', '');
                        break;
                    }
                }
                
                // Map some language aliases
                if (language === 'js') language = 'javascript';
                if (language === 'sh') language = 'bash';
                
                // Only proceed if it's a supported language
                if (['python', 'javascript', 'bash', 'shell'].includes(language)) {
                    if (language === 'shell') language = 'bash';
                    
                    // Get the code content and normalize indentation
                    const code = normalizeIndentation(codeBlock.textContent);
                    
                    // If this is the last code block, set it in the playground
                    if (index === codeBlocks.length - 1) {
                        // If this is a fix response and we have the original code, try to apply just the fix
                        if (isFixResponse && window.lastExecutedCode) {
                            // Check if this is a complete rewrite or just a fix
                            const codeLines = code.split('\n').length;
                            const originalLines = window.lastExecutedCode.split('\n').length;
                            
                            // For indentation errors, always use the complete rewrite
                            if (window.lastExecutedError && window.lastExecutedError.includes('IndentationError')) {
                                // Always use the complete code for indentation errors
                                document.getElementById('code-editor').value = code;
                            } else if (codeLines < originalLines / 2) {
                                // For other errors, if the code is significantly shorter than the original, it's likely just the fix
                                // Try to find context in the message to understand where to apply the fix
                                const messageText = messageElement.textContent;
                                
                                // Look for line numbers in the message
                                const lineMatches = messageText.match(/line\s*(\d+)|at\s*line\s*(\d+)|lines?\s*(\d+)-(\d+)|lines?\s*(\d+)\s*to\s*(\d+)/gi);
                                
                                if (lineMatches) {
                                    // We found line references, but for now let's just append the fix as a comment
                                    // This is a simple approach - a more sophisticated one would parse the line numbers
                                    // and apply the changes at the right location
                                    document.getElementById('code-editor').value = 
                                        window.lastExecutedCode + 
                                        '\n\n# Fix suggested by the model:\n' + 
                                        code;
                                } else {
                                    // No clear line references, append the fix as a comment
                                    document.getElementById('code-editor').value = 
                                        window.lastExecutedCode + 
                                        '\n\n# Fix suggested by the model:\n' + 
                                        code;
                                }
                            } else {
                                // This appears to be a complete rewrite, so replace the code
                                document.getElementById('code-editor').value = code;
                            }
                        } else {
                            // Not a fix response, just set the code in the playground
                            document.getElementById('code-editor').value = code;
                        }
                        
                        // Set the language
                        document.getElementById('code-language-select').value = language;
                        
                        // Add a visual indicator that code has been added
                        const codeEditor = document.getElementById('code-editor');
                        codeEditor.classList.add('highlight-animation');
                        setTimeout(() => {
                            codeEditor.classList.remove('highlight-animation');
                            
                            // Auto-run the code if enabled
                            if (shouldAutoRun) {
                                console.log('Auto-running code...');
                                executeCodeInPlayground();
                            }
                        }, 2000);
                    }
                    
                    // Hide the code block in the chat
                    // Find the parent pre element
                    const preElement = codeBlock.parentNode;
                    
                    // Create a message indicating code was moved
                    const codeMovedMsg = document.createElement('div');
                    codeMovedMsg.classList.add('code-moved-message');
                    codeMovedMsg.innerHTML = `<strong>Code moved to playground →</strong><br>Language: ${language}<br>Length: ${code.length} characters`;
                    
                    // Get the parent of the pre element (could be a code-block-container or directly in the message)
                    const parent = preElement.parentNode;
                    
                    // If the parent is a code-block-container, replace the entire container
                    if (parent.classList.contains('code-block-container')) {
                        parent.parentNode.replaceChild(codeMovedMsg, parent);
                    } else {
                        // Otherwise, just replace the pre element
                        parent.replaceChild(codeMovedMsg, preElement);
                    }
                }
            });
        }
        
        // Model selector event listener
        document.getElementById('model-select').addEventListener('change', function(event) {
            currentModel = event.target.value;
            console.log(`Model changed to: ${currentModel}`);
            
            // Update the current model display in the header
            document.getElementById('current-model-display').textContent = currentModel;
            
            // Add a system message indicating the model change
            const modelChangeMessage = `Model changed to: ${currentModel}`;
            addMessageToChat('assistant', modelChangeMessage, null, currentModel);
            
            // Fetch the list of available models to ensure we're in sync with the server
            fetch('/api/models')
                .then(response => response.json())
                .then(data => {
                    if (data.current !== currentModel) {
                        console.log(`Server model (${data.current}) differs from client model (${currentModel})`);
                    }
                })
                .catch(error => console.error('Error fetching models:', error));
        });
        
        // Code playground functionality
        document.getElementById('run-code-btn').addEventListener('click', function() {
            // Execute the code - parameters will be retrieved from the UI in the function
            executeCodeInPlayground();
        });
        
        // Clear code playground functionality
        document.getElementById('clear-code-btn').addEventListener('click', function() {
            document.getElementById('code-editor').value = '';
            document.getElementById('code-output').textContent = 'Output will appear here...';
        });
        
        // Function to execute code from the playground
        async function executeCodeInPlayground(code, language) {
            // If code and language are not provided, get them from the playground
            if (!code || !language) {
                code = document.getElementById('code-editor').value;
                language = document.getElementById('code-language-select').value;
                
                if (!code.trim()) {
                    document.getElementById('code-output').textContent = 'Please enter some code to execute.';
                    return;
                }
            }
            
            const codeOutput = document.getElementById('code-output');
            
            // Show loading state
            codeOutput.textContent = 'Executing...';
            codeOutput.classList.remove('code-error');
            
            // Store the original code and language in case we need to send it to the model for correction
            window.lastExecutedCode = code;
            window.lastExecutedLanguage = language;
            window.lastExecutedError = null; // Clear any previous error
            
            try {
                // Send the code to the server for execution
                const response = await fetch('/api/execute', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        code: code,
                        language: language
                    })
                });
                
                const data = await response.json();
                
                // Display the result
                if (data.error) {
                    codeOutput.textContent = `Error: ${data.error}`;
                    codeOutput.classList.add('code-error');
                    
                    // Store the error for reference when fixing
                    window.lastExecutedError = data.error;
                    
                    // If auto-fix is enabled, automatically send the error to the model
                    if (autoFixEnabled) {
                        // Show that we're automatically fixing the error
                        const autoFixingMsg = document.createElement('div');
                        autoFixingMsg.textContent = 'Auto-fixing error...';
                        autoFixingMsg.classList.add('auto-fixing-message');
                        
                        // Clear any existing messages or buttons
                        const existingElements = codeOutput.querySelectorAll('.fix-code-button, .auto-fixing-message');
                        existingElements.forEach(el => el.remove());
                        
                        codeOutput.appendChild(document.createElement('br'));
                        codeOutput.appendChild(autoFixingMsg);
                        
                        // Send the error to the model for correction
                        setTimeout(() => {
                            askModelToFixCode(window.lastExecutedCode, window.lastExecutedLanguage, data.error);
                        }, 500);
                    } else {
                        // Add a button to send the error to the model for correction
                        const fixButton = document.createElement('button');
                        fixButton.textContent = 'Ask Model to Fix';
                        fixButton.classList.add('fix-code-button');
                        fixButton.addEventListener('click', function() {
                            askModelToFixCode(window.lastExecutedCode, window.lastExecutedLanguage, data.error);
                        });
                        
                        // Clear any existing fix buttons before adding a new one
                        const existingButtons = codeOutput.querySelectorAll('.fix-code-button');
                        existingButtons.forEach(btn => btn.remove());
                        
                        codeOutput.appendChild(document.createElement('br'));
                        codeOutput.appendChild(fixButton);
                    }
                } else {
                    codeOutput.textContent = data.result || 'Code executed successfully with no output.';
                    codeOutput.classList.remove('code-error');
                }
            } catch (error) {
                codeOutput.textContent = `Error: ${error.message}`;
                codeOutput.classList.add('code-error');
            }
        }
        
        // Function to copy code from chat to playground
        function copyToPlayground(code, language) {
            const codeEditor = document.getElementById('code-editor');
            const languageSelect = document.getElementById('code-language-select');
            
            // Set the code in the editor
            codeEditor.value = code;
            
            // Set the language if it's supported
            if (['python', 'javascript', 'bash'].includes(language)) {
                languageSelect.value = language;
            }
            
            // Focus the code panel
            codeEditor.focus();
        }
        
        // Function to ask the model to fix code based on an error
        async function askModelToFixCode(code, language, error) {
            // Show a loading message in the chat
            const message = `Please fix this ${language} code. Here's the error:\n\n${error}\n\nHere's the code:\n\n\`\`\`${language}\n${code}\n\`\`\`\n\nThis code has an indentation error. Please provide the COMPLETE CORRECTED CODE with proper indentation. Be extremely careful with whitespace and indentation. Make sure all tabs and spaces are consistent throughout the code.`;
            
            // Add the user message to the chat
            addMessageToChat('user', message);
            
            // Get the current chat history
            const history = chatHistory.slice();
            
            // Create a unique ID for this response
            const responseId = 'response-' + Date.now();
            
            // Add a placeholder for the assistant's response
            const placeholder = `<div class="message-wrapper"><div class="message assistant-message" id="${responseId}"><div class="typing-indicator"><span></span><span></span><span></span></div></div></div>`;
            chatContainer.innerHTML += placeholder;
            
            // Scroll to the bottom of the chat
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            try {
                // Send the message to the server
                const response = await fetch('/api/chat/stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: message,
                        history: history,
                        model: currentModel
                    })
                });
                
                // Process the streaming response
                const reader = response.body.getReader();
                let decoder = new TextDecoder();
                let buffer = '';
                
                while (true) {
                    const { value, done } = await reader.read();
                    
                    if (done) {
                        break;
                    }
                    
                    // Decode the chunk and add it to the buffer
                    buffer += decoder.decode(value, { stream: true });
                    
                    // Process complete events in the buffer
                    let eventStart = buffer.indexOf('data: ');
                    let eventEnd = buffer.indexOf('\n\n', eventStart);
                    
                    while (eventStart >= 0 && eventEnd >= 0) {
                        // Extract the event data
                        const eventData = buffer.substring(eventStart + 6, eventEnd);
                        
                        try {
                            // Parse the event data as JSON
                            const data = JSON.parse(eventData);
                            
                            // Check if this is the final message
                            if (data.done) {
                                // Update the chat history
                                chatHistory = data.history;
                                
                                // Update the model if it changed
                                if (data.model && data.model !== currentModel) {
                                    currentModel = data.model;
                                    console.log(`Model changed to: ${currentModel}`);
                                    
                                    // Update the model selector to match
                                    const modelSelect = document.getElementById('model-select');
                                    if (modelSelect && modelSelect.value !== data.model) {
                                        modelSelect.value = data.model;
                                        
                                        // Also update the current model display in the header
                                        document.getElementById('current-model-display').textContent = data.model;
                                    }
                                }
                            } else {
                                // Update the placeholder with the current full response
                                const currentResponse = document.getElementById(responseId);
                                if (currentResponse) {
                                    // Save the model tag if it exists
                                    const existingModelTag = currentResponse.querySelector('.model-tag');
                                    let modelName = currentModel;
                                    if (existingModelTag) {
                                        // Extract model name from the tag text if it exists
                                        const tagText = existingModelTag.textContent;
                                        const match = tagText.match(/Model: (.+)/);
                                        if (match && match[1]) {
                                            modelName = match[1];
                                        }
                                    }
                                    
                                    // Parse markdown content using marked.js
                                    currentResponse.innerHTML = marked.parse(data.full);
                                    
                                    // Apply syntax highlighting to code blocks if hljs is available
                                    if (window.hljs) {
                                        currentResponse.querySelectorAll('pre code').forEach((block) => {
                                            hljs.highlightElement(block);
                                        });
                                    }
                                    
                                    // First extract code from the response and place it in the code playground
                                    // This will replace code blocks with messages
                                    extractAndPlaceCode(currentResponse);
                                    
                                    // Then add execute buttons to any remaining code blocks
                                    // (in case there are non-supported language code blocks)
                                    addCodeExecutionButtons(currentResponse);
                                    
                                    // Always add a model tag with the correct model
                                    const modelTag = document.createElement('div');
                                    modelTag.classList.add('model-tag');
                                    modelTag.textContent = `Model: ${modelName}`;
                                    currentResponse.appendChild(modelTag);
                                    
                                    // Scroll to bottom as content is added
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                }
                            }
                        } catch (e) {
                            console.error('Error parsing event data:', e);
                        }
                        
                        // Remove the processed event from the buffer
                        buffer = buffer.substring(eventEnd + 2);
                        
                        // Look for the next event
                        eventStart = buffer.indexOf('data: ');
                        eventEnd = buffer.indexOf('\n\n', eventStart);
                    }
                }
                
            } catch (error) {
                // Add error message to chat
                const currentResponse = document.getElementById(responseId);
                if (currentResponse) {
                    currentResponse.textContent = `Error: ${error.message}`;
                }
            }
        }
        
        // Define the debounced version of the extract code function
        const extractAndPlaceCode = debounce(extractAndPlaceCodeImpl, 500);  // 500ms debounce delay
    </script>
</body>
</html>
